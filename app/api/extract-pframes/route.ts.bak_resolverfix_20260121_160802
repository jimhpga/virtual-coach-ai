export const runtime = "nodejs";
import { NextResponse } from "next/server";
import { mkdir, writeFile, readFile, access } from "fs/promises";
import path from "path";
import os from "os";
import { execFile } from "child_process";
import * as fs from "fs";

type Body = {
  localPath?: string;
  videoUrl?: string;
  pathname?: string;
  impactSec?: number;
};

function run(cmd: string, args: string[]): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    execFile(cmd, args, { windowsHide: true }, (err, stdout, stderr) => {
      if (err) return reject(new Error((stderr || stdout || err.message).toString()));
      resolve({ stdout: (stdout || "").toString(), stderr: (stderr || "").toString() });
    });
  });
}

async function downloadToFile(url: string, outPath: string) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Download failed (${res.status})`);
  const arr = new Uint8Array(await res.arrayBuffer());
  await fs.promises.writeFile(outPath, arr);
}

async function ffprobeDurationSeconds(inputPath: string): Promise<number> {
  const { stdout } = await run("ffprobe", [
    "-v", "error",
    "-show_entries", "format=duration",
    "-of", "json",
    inputPath,
  ]);
  const j = JSON.parse(stdout);
  const d = Number(j?.format?.duration || 0) || 0;
  return d;
}

function clamp(n: number, lo: number, hi: number) {
  return Math.max(lo, Math.min(hi, n));
}

function linspace(a: number, b: number, n: number) {
  if (n <= 1) return [a];
  const out: number[] = [];
  const step = (b - a) / (n - 1);
  for (let i = 0; i < n; i++) out.push(a + step * i);
  return out;
}

export async function POST(req: Request) {
  let tmpDir: string | null = null;
  let tempInput: string | null = null;

  try {
        // ---- VCA request body (safe JSON) ----
    const __raw = await req.text();
    let __t = (__raw ?? "").trim();

    // strip UTF-8 BOM if present
    if (__t.charCodeAt(0) === 0xFEFF) __t = __t.slice(1);

    const __head = __t.slice(0, 80);
    const __codes = Array.from(__head).map(c => c.charCodeAt(0)).join(",");

    // Debug: echo what server received (no side effects)
    if (req.headers.get("x-vca-echo") === "1") {
      return NextResponse.json({ ok: true, head: __head, codes: __codes, len: __t.length }, { status: 200 });
    }

    let body: Body;
    try {
      body = (__t ? JSON.parse(__t) : {}) as Body;
    } catch (e: any) {
      return NextResponse.json({ ok: false, error: "Bad JSON body", head: __head, codes: __codes }, { status: 400 });
    }
    // --------------------------------------

    const localPath = typeof body.localPath === "string" ? body.localPath : null;
    const videoUrl  = typeof body.videoUrl === "string" ? body.videoUrl : null;
    const pathname  = typeof body.pathname === "string" ? body.pathname : null;
    const impactSec = (typeof body.impactSec === "number" && body.impactSec > 0) ? body.impactSec : 2.0; // default for site flow
if (!localPath && !videoUrl) {
      return NextResponse.json({ ok: false, error: "Provide localPath or videoUrl." }, { status: 400 });
    }

    // Decide input file path
    let inputPath = localPath || "";
    if (!inputPath && videoUrl) {
      // ✅ Site behavior: "/uploads/..." is a local file in /public, not a fetchable URL.
      if (videoUrl.startsWith("/")) {
        inputPath = path.join(process.cwd(), "public", videoUrl.replace(/^\/+/, ""));
      } else {
        // download URL to tmp (only for real http(s) URLs)
        tmpDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), "vca-pframes-"));
        const safeName =
          (pathname && pathname.trim()) ||
          `upload-${Date.now()}.mp4`;
        const fileName = safeName.replace(/[^\w.\-]+/g, "_");
        tempInput = path.join(tmpDir, fileName);
        await downloadToFile(videoUrl, tempInput);
        inputPath = tempInput;
      }
    }
    // --- AUTO-RESOLVE UPLOAD ID (no extension) ---
    // Some site flows pass "/uploads/<id>" instead of "/uploads/<filename.ext>".
    // If the exact path doesn't exist, try matching a real file in /public/uploads that starts with the id.
    if (!fs.existsSync(inputPath)) {
      try {
        const uploadsAbs = path.join(process.cwd(), "public", "uploads");
        const base = path.basename(inputPath);
        const hasExt = base.includes(".");
        const looksLikeUploads =
          inputPath.replace(/\\/g, "/").includes("/public/uploads/") ||
          inputPath.replace(/\\/g, "/").includes("/uploads/");

        if (looksLikeUploads && !hasExt) {
          const files = fs.readdirSync(uploadsAbs);
          const hit = files.find((n) => n.startsWith(base));
          if (hit) {
            inputPath = path.join(uploadsAbs, hit);
          }
        }
      } catch (e) {
        // swallow; normal not-found will be handled below
      }
    }
    // --- END AUTO-RESOLVE ---
    if (!fs.existsSync(inputPath)) {
      return NextResponse.json({ ok: false, error: `Input file not found: ${inputPath}` }, { status: 400 });
    }

    const durationSec = await ffprobeDurationSeconds(inputPath);
    // --- Auto-impact fallback (site-mode): if impactSec not provided, estimate it ---
    // We bias slightly past midpoint to land closer to real impact in typical swing clips.
    const fallbackImpactSec = clamp(durationSec * 0.55, 0.20, Math.max(0.20, durationSec - 0.20));
    const impact = (typeof impactSec === "number" && impactSec > 0) ? impactSec : fallbackImpactSec;
    if (!durationSec || durationSec <= 0) {
      return NextResponse.json({ ok: false, error: "Could not read duration (ffprobe)." }, { status: 500 });
    }

    // Build a simple P1-P9 timeline around impact
    // Window: ~2.5s before impact to ~1.5s after (clamped to video)
    const start = clamp(impact - 2.5, 0.0, durationSec);
    const end   = clamp(impact + 1.5, 0.0, durationSec);

    const preEnd = clamp(impact - 0.10, 0.0, durationSec);
    const postStart = clamp(impact + 0.10, 0.0, durationSec);

    // P1..P6 spread from start..preEnd, P7 = impact, P8..P9 from postStart..end
    const pre = linspace(start, preEnd, 6);
    const post = linspace(postStart, end, 2);
    const times = [...pre, impact, ...post]; // total 9

    const outId = `frames_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const framesDir = `/frames/${outId}`;
    const framesAbs = path.join(process.cwd(), "public", "frames", outId);
    await fs.promises.mkdir(framesAbs, { recursive: true });

    // Extract frames
    for (let i = 0; i < 9; i++) {
      const p = i + 1;
      const t = clamp(times[i], 0.0, durationSec);

      const outJpg = path.join(framesAbs, `p${p}.jpg`);

      // -ss before -i is faster for keyframe-ish seeks; good enough here
      await run("ffmpeg", [
        "-y",
        "-ss", t.toFixed(3),
        "-i", inputPath,
        "-an",
        "-frames:v", "1",
        "-vf", "format=yuvj420p",
        "-q:v", "2",
        "-strict", "-2",
        outJpg,
      ]);
    }

    const pframes = Array.from({ length: 9 }).map((_, i) => {
      const p = i + 1;
      const img = `${framesDir}/p${p}.jpg`;
      return { p, label: `P${p}`, imageUrl: img, thumbUrl: img };
    });

    const checkpoints = Array.from({ length: 9 }).map((_, i) => {
      const p = i + 1;
      return { p, label: `P${p}`, note: "-" };
    });

    return NextResponse.json({
      ok: true,
      framesDir,
      pframes,
      checkpoints,
      topFaults: [],
      meta: {
        durationSec,
        impactSec: impact,
        source: { localPath, videoUrl, pathname },
      },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "extract-pframes failed" }, { status: 500 });
  } finally {
    // cleanup downloaded temp file
    try { if (tempInput) await fs.promises.unlink(tempInput); } catch {}
    try { if (tmpDir) await fs.promises.rm(tmpDir, { recursive: true, force: true }); } catch {}
  }
}















