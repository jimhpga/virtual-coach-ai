import { NextResponse } from "next/server";
import { mkdir, writeFile } from "fs/promises";
import path from "path";

async function __vcaDump(tag: string, payload: any) {
  try {
    if (process.env.NODE_ENV === "production") return;

    const jobId =
      payload?.id ??
      payload?.jobId ??
      payload?.job?.id ??
      payload?.data?.id ??
      `dev_${Date.now()}`;

    const dir = path.join(process.cwd(), ".data", "jobs", String(jobId));
    await mkdir(dir, { recursive: true });

    const write = async (name: string, obj: any) => {
      if (obj === undefined) return;
      const p = path.join(dir, name);
      await writeFile(p, JSON.stringify(obj, null, 2), "utf8");
    };

    await write("response.json", payload);
    await write(`${tag}.json`, payload);

    // Optional common keys (if present)
    await write("ai_raw.json", payload?.ai_raw ?? payload?.aiRaw ?? payload?.raw ?? payload?.model_raw);
    await write("ai_parsed.json", payload?.ai_parsed ?? payload?.aiParsed ?? payload?.parsed ?? payload?.model_parsed);
    await write("ai_summary.json", payload?.ai_summary ?? payload?.aiSummary ?? payload?.summary ?? payload?.report);
  } catch {}
}

export const runtime = "nodejs";

type ExtractResp = {
  ok: boolean;
  jobId?: string;
  videoUrl?: string;
  framesDir?: string;   // "/frames/<jobId>"
  frames?: Array<{ p: number; label: string; file: string; url: string }>;
  error?: string;
};

export async function POST(req: Request) {
  try {
    const body = await req.json().catch(() => ({}));
    const videoUrl = String(body?.videoUrl || "");
    const uploadId = String(body?.uploadId || "");

    const v = videoUrl || (uploadId ? `/uploads/${uploadId}` : "");

    if (!v || !v.startsWith("/uploads/")) {
          // FINAL_NORMALIZE_REPORT (do not remove)
    report.headline = String(report.headline || "P1-P9 frames ready.").replace(/P1[–â]P9/g, "P1-P9");
    if (!Array.isArray((report as any).topFaults)) (report as any).topFaults = [];
    return NextResponse.json(
        { ok: false, error: "videoUrl must start with /uploads/" },
        { status: 400 }
      );
    }

    const base = new URL(req.url).origin;

    // Call extract-pframes (which now creates /public/frames/<jobId>/p1..p9.jpg)
    const r = await fetch(`${base}/api/extract-pframes`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ videoUrl: v }),
    });

    const data = (await r.json().catch(() => null)) as ExtractResp | null;

    if (!r.ok || !data || !data.ok) {
          // FINAL_NORMALIZE_REPORT (do not remove)
    report.headline = String(report.headline || "P1-P9 frames ready.").replace(/P1[–â]P9/g, "P1-P9");
    if (!Array.isArray((report as any).topFaults)) (report as any).topFaults = [];
    return NextResponse.json(
        { ok: false, error: data?.error || `extract-pframes failed (${r.status})` },
        { status: 500 }
      );
    }

    const framesDir = data.framesDir || "";
    const frames = Array.isArray(data.frames) ? data.frames : [];

    // Build a clean P1-P9 array your UI can use right now
    const pframes = frames
      .slice()
      .sort((a, b) => (a.p || 0) - (b.p || 0))
      .map((f) => ({
        p: f.p,
        label: f.label || `P${f.p}`,
        imageUrl: f.url,         // "/frames/<jobId>/p#.jpg"
        thumbUrl: f.url,         // same for now
      }));

    // Minimal report object (replace later with real scoring + faults)
    const report = {
      id: `rpt_${Date.now()}`,
      createdAt: new Date().toISOString(),
      headline: "P1-P9 frames ready.",
      swingScore: 72,
      topFaults: [],
      checkpoints: pframes.map((pf) => ({ p: pf.p, label: pf.label, note: "-" })),
      pframes,                  // <-- key payload for the strip
      framesDir,                // handy for debugging + direct viewing
    };

        // FINAL_NORMALIZE_REPORT (do not remove)
    report.headline = String(report.headline || "P1-P9 frames ready.").replace(/P1[–â]P9/g, "P1-P9");
    if (!Array.isArray((report as any).topFaults)) (report as any).topFaults = [];
    return NextResponse.json({
      ok: true,
      videoUrl: v,
      framesDir,
      frames,
      report,
    });
  } catch (e: any) {
        // FINAL_NORMALIZE_REPORT (do not remove)
    report.headline = String(report.headline || "P1-P9 frames ready.").replace(/P1[–â]P9/g, "P1-P9");
    if (!Array.isArray((report as any).topFaults)) (report as any).topFaults = [];
    return NextResponse.json(
      { ok: false, error: e?.message || "Analyze failed" },
      { status: 500 }
    );
  }
}




