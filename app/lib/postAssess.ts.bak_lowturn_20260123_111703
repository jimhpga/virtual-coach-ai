// app/lib/postAssess.ts
// Deterministic post-assessment from pose frames (MediaPipe-style 33 landmarks).
// No fetch. No randomness.

export type FaultKey =
  | "face_open"
  | "face_closed"
  | "early_extend"
  | "over_the_top"
  | "late_hips"
  | "arms_start_down"
  | "flip"
  | "sway"
  | "reverse_pivot"
  | "foundation";

export type PoseLandmark = { x: number; y: number; z?: number; v?: number };
export type PoseFrame = { frame: number; t?: number; ok?: boolean; w?: number; h?: number; landmarks: PoseLandmark[] };

export type PoseJson = {
  version?: number;
  fps?: number;
  width?: number;
  height?: number;
  frames: PoseFrame[];
};

export type AnalyzeResponse = {
  faults?: FaultKey[];
  faultKeys?: FaultKey[];
  frames?: PoseFrame[];
  fps?: number;
  input?: any;
  meta?: any;
  scores?: { swing?: number; power?: number; reliability?: number };
  narrative?: any;
};

const PRIORITY_ORDER: FaultKey[] = [
  "face_open",
  "face_closed",
  "over_the_top",
  "early_extend",
  "late_hips",
  "arms_start_down",
  "flip",
  "sway",
  "reverse_pivot",
  "foundation",
];

function pickOne(faults: FaultKey[] = []) {
  for (const k of PRIORITY_ORDER) if (faults.includes(k)) return k;
  return faults[0] || "foundation";
}

function humanLabel(key: string) {
  const map: Record<string, string> = {
    face_open: "Clubface control (open)",
    face_closed: "Clubface control (closed)",
    over_the_top: "Path (over the top)",
    early_extend: "Posture (early extension)",
    late_hips: "Sequence (hips late / low separation)",
    arms_start_down: "Sequence (arms start down first)",
    flip: "Impact (handle stalls / flip)",
    sway: "Pressure shift (sway)",
    reverse_pivot: "Pressure shift (reverse pivot)",
    foundation: "Foundation (setup + contact)",
  };
  const k = typeof key === "string" ? key : "";
  return map[k] || (k ? k.replace(/_/g, " ") : "");
}

// MediaPipe Pose landmark indices (33)
const L_SHOULDER = 11, R_SHOULDER = 12;
const L_HIP = 23, R_HIP = 24;
const L_WRIST = 15, R_WRIST = 16;
const L_ANKLE = 27, R_ANKLE = 28;

function isNum(n: any) {
  return typeof n === "number" && Number.isFinite(n);
}

function lm(frame: PoseFrame, idx: number): PoseLandmark | null {
  const a = frame?.landmarks;
  if (!a || !Array.isArray(a) || idx < 0 || idx >= a.length) return null;
  const p = a[idx];
  if (!p) return null;
  if (!isNum(p.x) || !isNum(p.y)) return null;
  return p;
}

function mid(a: PoseLandmark | null, b: PoseLandmark | null) {
  if (!a || !b) return null;
  return {
    x: (a.x + b.x) / 2,
    y: (a.y + b.y) / 2,
    z: (isNum(a.z) && isNum(b.z)) ? ((a.z! + b.z!) / 2) : undefined,
    v: (isNum(a.v) && isNum(b.v)) ? ((a.v! + b.v!) / 2) : undefined,
  } as PoseLandmark;
}

function dist2D(a: PoseLandmark | null, b: PoseLandmark | null) {
  if (!a || !b) return null;
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function clamp(x: number, a: number, b: number) {
  return Math.max(a, Math.min(b, x));
}
function clamp01(x: number) {
  return clamp(x, 0, 1);
}

function medianNums(xs: number[]) {
  const a = xs.filter(isNum).sort((x, y) => x - y);
  if (!a.length) return null;
  const m = Math.floor(a.length / 2);
  return a.length % 2 ? a[m] : (a[m - 1] + a[m]) / 2;
}

function angleDeg(a: PoseLandmark | null, b: PoseLandmark | null) {
  if (!a || !b) return null;
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return (Math.atan2(dy, dx) * 180) / Math.PI;
}
function normDeltaDeg(d: number) {
  let x = d;
  while (x > 180) x -= 360;
  while (x < -180) x += 360;
  return x;
}

// Pose-only phase picks (works even on trimmed clips)
function pickPhases(frames: PoseFrame[]) {
  if (!frames.length) return { setup: null as any, top: null as any, impact: null as any };

  const setup =
    frames.find(f => lm(f, L_HIP) && lm(f, R_HIP) && lm(f, L_SHOULDER) && lm(f, R_SHOULDER)) || frames[0];

  const n = frames.length;
  const firstHalf = frames.slice(0, Math.max(5, Math.floor(n * 0.55)));
  const secondHalf = frames.slice(Math.floor(n * 0.45));

  const handHighY = (f: PoseFrame) => {
    const lw = lm(f, L_WRIST);
    const rw = lm(f, R_WRIST);
    if (lw && rw) return Math.min(lw.y, rw.y);
    if (lw) return lw.y;
    if (rw) return rw.y;
    return null;
  };

  const handLowY = (f: PoseFrame) => {
    const lw = lm(f, L_WRIST);
    const rw = lm(f, R_WRIST);
    if (lw && rw) return Math.max(lw.y, rw.y);
    if (lw) return lw.y;
    if (rw) return rw.y;
    return null;
  };

  let top = firstHalf[0];
  let topVal = 9;
  for (const f of firstHalf) {
    const y = handHighY(f);
    if (y !== null && y < topVal) { topVal = y; top = f; }
  }

  // "impact-ish" = lowest hands near the end; if clip is trimmed, pick lowest hands after top
  let impact = secondHalf[0];
  let impVal = -1;
  for (const f of secondHalf) {
    const y = handLowY(f);
    if (y !== null && y > impVal) { impVal = y; impact = f; }
  }

  // Safety: if impact is suspiciously close to top (trimmed), still OK — downstream uses adaptive window.
  return { setup, top, impact };
}

function inferFaultsFromPose(pose: PoseJson): { faults: FaultKey[]; metrics: any } {
  const frames = Array.isArray(pose?.frames) ? pose.frames : [];
  if (frames.length < 8) {
    return { faults: ["foundation"], metrics: { reason: "not_enough_frames" } };
  }

  const track = frames.map((f) => {
    const lHip = lm(f, L_HIP), rHip = lm(f, R_HIP);
    const lSh = lm(f, L_SHOULDER), rSh = lm(f, R_SHOULDER);
    const lAn = lm(f, L_ANKLE), rAn = lm(f, R_ANKLE);
    const pel = mid(lHip, rHip);
    const tor = mid(lSh, rSh);
    const ank = mid(lAn, rAn);

    const shAng = angleDeg(lSh, rSh);
    const hipAng = angleDeg(lHip, rHip);

    const lw = lm(f, L_WRIST);
    const rw = lm(f, R_WRIST);
    const wMid = mid(lw, rw);

    const torsoOverFeet = (tor && ank) ? (tor.x - ank.x) : null;

    return {
      f,
      pel,
      tor,
      ank,
      shAng,
      hipAng,
      wMid,
      torsoOverFeet,
      ok: f?.ok !== false,
    };
  }).filter(r => r.pel && r.tor);

  if (track.length < 8) {
    return { faults: ["foundation"], metrics: { reason: "insufficient_keypoints" } };
  }

  const { setup, top, impact } = pickPhases(track.map(t => t.f));
  const getRow = (frame: PoseFrame | null) => frame ? track.find(t => t.f === frame) || null : null;
  const s = getRow(setup);
  const t = getRow(top);
  const i = getRow(impact);

  const faults: FaultKey[] = [];

  // Range of pelvis x (normalized) for sway check
  const pelXs = track.map(r => r.pel!.x);
  const pelRange = Math.max(...pelXs) - Math.min(...pelXs);

  // Separation proxy (median torso.x - pelvis.x abs)
  const sepMed = medianNums(track.map(r => Math.abs(r.tor!.x - r.pel!.x))) ?? 0;

  // Rotation proxy ranges (setup->top)
  const shTurn = (s && t && s.shAng !== null && t.shAng !== null) ? Math.abs(normDeltaDeg(t.shAng! - s.shAng!)) : 0;
  const hipTurn = (s && t && s.hipAng !== null && t.hipAng !== null) ? Math.abs(normDeltaDeg(t.hipAng! - s.hipAng!)) : 0;

  // 1) SWAY
  const sway = pelRange > 0.085;
  if (sway) faults.push("sway");

  // 2) EARLY EXTENSION proxy (setup->impact)
  if (s && i) {
    const pelRise = (s.pel!.y - i.pel!.y); // positive if hips moved UP (y decreased)
    const torsoOverFeetS = s.torsoOverFeet;
    const torsoOverFeetI = i.torsoOverFeet;
    const torsoShift = (torsoOverFeetS !== null && torsoOverFeetI !== null) ? (torsoOverFeetI - torsoOverFeetS) : 0;

    if (pelRise > 0.040 && Math.abs(torsoShift) > 0.030) {
      faults.push("early_extend");
    }
  }

  // 3) REVERSE PIVOT proxy (setup->top pelvis+torso opposite drift)
  if (s && t) {
    const pelDx = (t.pel!.x - s.pel!.x);
    const torDx = (t.tor!.x - s.tor!.x);
    const opp = (pelDx * torDx) < 0;
    const bigEnough = (Math.abs(pelDx) + Math.abs(torDx)) > 0.060;
    if (opp && bigEnough) faults.push("reverse_pivot");
  }

  // 4) SEQUENCING + OTT using adaptive downswing window
  if (t) {
    const idxTop = track.findIndex(r => r.f === t.f);

    // Find a sensible downswing sample index:
    // Prefer impact index if it exists after top, otherwise use +8 frames.
    let idxImp = -1;
    if (i) idxImp = track.findIndex(r => r.f === i.f);

    let idxDn = -1;
    if (idxTop >= 0) {
      if (idxImp > idxTop) {
        const span = idxImp - idxTop;
        // sample halfway to impact, but at least +4 frames
        idxDn = idxTop + Math.max(4, Math.floor(span * 0.5));
        if (idxDn > idxImp) idxDn = idxImp;
      } else {
        idxDn = Math.min(track.length - 1, idxTop + 8);
      }
    }

    if (idxTop >= 0 && idxDn > idxTop && idxDn < track.length) {
      const rTop = track[idxTop];
      const rDn  = track[idxDn];

      const dSh = (rTop.shAng !== null && rDn.shAng !== null) ? normDeltaDeg(rDn.shAng! - rTop.shAng!) : 0;
      const dHp = (rTop.hipAng !== null && rDn.hipAng !== null) ? normDeltaDeg(rDn.hipAng! - rTop.hipAng!) : 0;

      const shSpeed = Math.abs(dSh);
      const hpSpeed = Math.abs(dHp);

      const wTop = rTop.wMid;
      const wDn  = rDn.wMid;

      const wDrop = (wTop && wDn) ? (wDn.y - wTop.y) : 0; // hands moved DOWN
      const pelMove = Math.abs(rDn.pel!.x - rTop.pel!.x);

      // Arms start down: hands drop but pelvis barely moves
      if (wDrop > 0.030 && pelMove < 0.012) {
        faults.push("arms_start_down");
      }

      // Late hips: hips barely rotate while shoulders move
      if (hpSpeed < 5 && shSpeed > 8) {
        faults.push("late_hips");
      }

      // OTT: shoulders move more than hips AND hands drift outward relative to pelvis
      const wOut = (wTop && wDn) ? (Math.abs(wDn.x - rTop.pel!.x) - Math.abs(wTop.x - rTop.pel!.x)) : 0;
      if (shSpeed > (hpSpeed + 8) && wOut > 0.006) {
        faults.push("over_the_top");
      }
    }
  }

  // 5) NEW: If separation proxy is very low, call it "late_hips" (sequence/turn deficiency)
  // Your current sepMed ~0.027 — that is low. This gives you something real instead of "foundation".
  // Threshold tuned for normalized coordinates.
  if (sepMed < 0.030) {
    if (!faults.includes("late_hips")) faults.push("late_hips");
  }

  // 6) NEW: If shoulder+hip "turn" proxies are both tiny, treat as foundation/turn deficiency.
  // If already have a fault, we keep it; otherwise we push late_hips (more actionable than "foundation").
  if (shTurn < 6 && hipTurn < 4) {
    if (!faults.length) faults.push("late_hips");
  }

  // Cleanup
  const uniq = Array.from(new Set(faults));
  const cleaned = (uniq.length > 1 && uniq.includes("foundation"))
    ? uniq.filter(f => f !== "foundation")
    : (uniq.length ? uniq : ["foundation"]);

  // ---------- Scores (0..100) ----------
  const okRate = track.filter(r => r.ok).length / track.length;
  const reliability = Math.round(60 + 40 * clamp01(okRate)); // 60–100

  const nonFoundation = cleaned.filter(f => f !== "foundation");
  const penalty = nonFoundation.length * 10;
  const swing = clamp(Math.round(92 - penalty), 30, 100);

  const power = clamp(Math.round(55 + 55 * clamp01(sepMed / 0.12)), 30, 100);

  return {
    faults: cleaned,
    metrics: {
      framesUsed: track.length,
      pelRange,
      sway,
      setupFrame: setup?.frame ?? null,
      topFrame: top?.frame ?? null,
      impactFrame: impact?.frame ?? null,
      okRate,
      sepMed,
      shTurn,
      hipTurn,
      scores: { swing, power, reliability },
    },
  };
}

export function postAssess(args: { pose?: PoseJson; base?: AnalyzeResponse } | AnalyzeResponse) {
  const base = (args as any)?.base ? (args as any).base : (args as any);

  const pose: PoseJson | undefined = (args as any)?.pose
    ? (args as any).pose
    : (base?.frames ? { fps: base?.fps, frames: base.frames } : undefined);

  const existing = (base?.faults ?? base?.faultKeys ?? []) as FaultKey[];
  let faults: FaultKey[] = Array.isArray(existing) ? [...existing] : [];

  let metrics: any = {};
  if (pose?.frames?.length) {
    const inferred = inferFaultsFromPose(pose);
    metrics = inferred.metrics;

    const baseIsEmptyish =
      !faults.length || (faults.length === 1 && faults[0] === "foundation");

    if (baseIsEmptyish) {
      faults = inferred.faults;
    } else {
      const set = new Set<FaultKey>(faults);
      for (const k of inferred.faults) set.add(k);
      faults = Array.from(set);
      if (faults.length > 1 && faults.includes("foundation")) {
        faults = faults.filter(f => f !== "foundation");
      }
    }
  } else {
    if (!faults.length) faults = ["foundation"];
  }

  const priority = pickOne(faults);

  const whyNow =
    priority === "foundation"
      ? "Lock in predictable contact first. Everything else gets easier once strike is stable."
      : `Fixing ${humanLabel(priority)} gives you the biggest “one move” gain right now—better starts, better strike, less chaos.`;

  const avoidList =
    priority === "face_open" || priority === "face_closed"
      ? "Avoid chasing swing path today. Face first, path second."
      : "Avoid chasing more speed today. Clean contact and sequence first.";

  const confidenceCue =
    "Expect a small confidence dip while you change the pattern. That’s normal—stay calm, take slower reps, and measure progress by contact + start line.";

  const scores = metrics?.scores ?? base?.scores ?? { swing: undefined, power: undefined, reliability: undefined };

  return {
    faults,
    faultKeys: faults,
    scores,
    narrative: {
      priorityKey: priority,
      priorityLabel: humanLabel(priority),
      whyNow,
      avoidList,
      confidenceCue,
      inferredFromPose: true,
      metrics,
    },
    priorityKey: priority,
    priorityLabel: humanLabel(priority),
    whyNow,
    avoidList,
    confidenceCue,
  };
}
