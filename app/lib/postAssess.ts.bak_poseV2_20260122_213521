// app/lib/postAssess.ts
// Deterministic post-assessment from pose frames (MediaPipe-style 33 landmarks).
// No fetch. No randomness. Safe to call anywhere.

export type FaultKey =
  | "face_open"
  | "face_closed"
  | "early_extend"
  | "over_the_top"
  | "late_hips"
  | "arms_start_down"
  | "flip"
  | "sway"
  | "reverse_pivot"
  | "foundation";

export type PoseLandmark = { x: number; y: number; z?: number; v?: number };
export type PoseFrame = { frame: number; t?: number; ok?: boolean; w?: number; h?: number; landmarks: PoseLandmark[] };

export type PoseJson = {
  version?: number;
  fps?: number;
  width?: number;
  height?: number;
  frames: PoseFrame[];
};

export type AnalyzeResponse = {
  faults?: FaultKey[];
  faultKeys?: FaultKey[];
  frames?: PoseFrame[];
  fps?: number;
  input?: any;
  meta?: any;
  scores?: { swing?: number; power?: number; reliability?: number };
  narrative?: any;
};

const PRIORITY_ORDER: FaultKey[] = [
  "face_open",
  "face_closed",
  "early_extend",
  "over_the_top",
  "late_hips",
  "arms_start_down",
  "flip",
  "sway",
  "reverse_pivot",
  "foundation",
];

function pickOne(faults: FaultKey[] = []) {
  for (const k of PRIORITY_ORDER) if (faults.includes(k)) return k;
  return faults[0] || "foundation";
}

function humanLabel(key: string) {
  const map: Record<string, string> = {
    face_open: "Clubface control (open)",
    face_closed: "Clubface control (closed)",
    over_the_top: "Path (over the top)",
    early_extend: "Posture (early extension)",
    late_hips: "Sequence (hips late)",
    arms_start_down: "Sequence (arms start down first)",
    flip: "Impact (handle stalls / flip)",
    sway: "Pressure shift (sway)",
    reverse_pivot: "Pressure shift (reverse pivot)",
    foundation: "Foundation (setup + contact)",
  };
  const k = typeof key === "string" ? key : "";
  return map[k] || (k ? k.replace(/_/g, " ") : "");
}

// MediaPipe Pose landmark indices (33)
const L_SHOULDER = 11, R_SHOULDER = 12;
const L_HIP = 23, R_HIP = 24;
const L_WRIST = 15, R_WRIST = 16;
const L_ANKLE = 27, R_ANKLE = 28;

function isNum(n: any) {
  return typeof n === "number" && Number.isFinite(n);
}

function lm(frame: PoseFrame, idx: number): PoseLandmark | null {
  const a = frame?.landmarks;
  if (!a || !Array.isArray(a) || idx < 0 || idx >= a.length) return null;
  const p = a[idx];
  if (!p) return null;
  if (!isNum(p.x) || !isNum(p.y)) return null;
  return p;
}

function mid(a: PoseLandmark | null, b: PoseLandmark | null) {
  if (!a || !b) return null;
  return {
    x: (a.x + b.x) / 2,
    y: (a.y + b.y) / 2,
    z: (isNum(a.z) && isNum(b.z)) ? ((a.z! + b.z!) / 2) : undefined,
    v: (isNum(a.v) && isNum(b.v)) ? ((a.v! + b.v!) / 2) : undefined,
  } as PoseLandmark;
}

function dist2D(a: PoseLandmark | null, b: PoseLandmark | null) {
  if (!a || !b) return null;
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function clamp01(x: number) {
  return Math.max(0, Math.min(1, x));
}

function median<T>(arr: T[], proj: (t: T) => number) {
  const xs = arr.map(proj).filter(isNum).sort((a, b) => a - b);
  if (!xs.length) return null;
  const m = Math.floor(xs.length / 2);
  return xs.length % 2 ? xs[m] : (xs[m - 1] + xs[m]) / 2;
}

// Pick crude swing phases from pose only (no club):
// - setup = early stable frame
// - top = frame where hands are highest (smallest y) during first half
// - impact-ish = frame where hands are lowest (largest y) during second half
function pickPhases(frames: PoseFrame[]) {
  if (!frames.length) return { setup: null as any, top: null as any, impact: null as any };

  const setup = frames.find(f => lm(f, L_HIP) && lm(f, R_HIP) && lm(f, L_SHOULDER) && lm(f, R_SHOULDER)) || frames[0];

  const n = frames.length;
  const firstHalf = frames.slice(0, Math.max(3, Math.floor(n * 0.55)));
  const secondHalf = frames.slice(Math.floor(n * 0.45));

  const handY = (f: PoseFrame) => {
    const lw = lm(f, L_WRIST);
    const rw = lm(f, R_WRIST);
    if (lw && rw) return Math.min(lw.y, rw.y);
    if (lw) return lw.y;
    if (rw) return rw.y;
    return null;
  };

  const lowHandY = (f: PoseFrame) => {
    const lw = lm(f, L_WRIST);
    const rw = lm(f, R_WRIST);
    if (lw && rw) return Math.max(lw.y, rw.y);
    if (lw) return lw.y;
    if (rw) return rw.y;
    return null;
  };

  let top = firstHalf[0];
  let topVal = 9;
  for (const f of firstHalf) {
    const y = handY(f);
    if (y !== null && y < topVal) { topVal = y; top = f; }
  }

  let impact = secondHalf[0];
  let impVal = -1;
  for (const f of secondHalf) {
    const y = lowHandY(f);
    if (y !== null && y > impVal) { impVal = y; impact = f; }
  }

  return { setup, top, impact };
}

// Core pose-to-fault inference (deterministic, conservative)
function inferFaultsFromPose(pose: PoseJson): { faults: FaultKey[]; metrics: any } {
  const frames = Array.isArray(pose?.frames) ? pose.frames : [];
  if (frames.length < 5) {
    return { faults: ["foundation"], metrics: { reason: "not_enough_frames" } };
  }

  const track = frames.map((f) => {
    const lHip = lm(f, L_HIP), rHip = lm(f, R_HIP);
    const lSh = lm(f, L_SHOULDER), rSh = lm(f, R_SHOULDER);
    const lAn = lm(f, L_ANKLE), rAn = lm(f, R_ANKLE);
    const pel = mid(lHip, rHip);
    const tor = mid(lSh, rSh);
    const ank = mid(lAn, rAn);
    const shoulderWidth = dist2D(lSh, rSh);
    const hipWidth = dist2D(lHip, rHip);
    const torsoOverFeet = (tor && ank) ? (tor.x - ank.x) : null;

    return {
      f,
      pel,
      tor,
      ank,
      shoulderWidth,
      hipWidth,
      torsoOverFeet,
      ok: f?.ok !== false,
    };
  }).filter(r => r.pel && r.tor);

  if (track.length < 5) {
    return { faults: ["foundation"], metrics: { reason: "insufficient_keypoints" } };
  }

  const { setup, top, impact } = pickPhases(track.map(t => t.f));
  const getRow = (frame: PoseFrame | null) => frame ? track.find(t => t.f === frame) || null : null;
  const s = getRow(setup);
  const t = getRow(top);
  const i = getRow(impact);

  const faults: FaultKey[] = [];

  const medShoulder = median(track, r => r.shoulderWidth ?? 0) ?? 0;
  const medHip = median(track, r => r.hipWidth ?? 0) ?? 0;
  const scale = medShoulder || medHip || 0.25;

  // SWAY: pelvis x range too large
  const pelXs = track.map(r => r.pel!.x);
  const pelRange = Math.max(...pelXs) - Math.min(...pelXs);
  const swayThresh = 0.22 * scale;
  const sway = pelRange > swayThresh;
  if (sway) faults.push("sway");

  // EARLY EXTENSION proxy: hips rise + torso shifts (proxy only—pose doesn't know "ball line")
  if (s && i) {
    const pelRise = (s.pel!.y - i.pel!.y);
    const torsoOverFeetS = s.torsoOverFeet;
    const torsoOverFeetI = i.torsoOverFeet;
    const torsoShift = (torsoOverFeetS !== null && torsoOverFeetI !== null) ? (torsoOverFeetI - torsoOverFeetS) : 0;

    const pelRiseThresh = 0.12 * scale;
    const torsoShiftThresh = 0.10 * scale;

    if (pelRise > pelRiseThresh && Math.abs(torsoShift) > torsoShiftThresh) {
      faults.push("early_extend");
    }
  }

  // REVERSE PIVOT proxy: upper and lower drift opposite directions in backswing
  if (s && t) {
    const pelDx = (t.pel!.x - s.pel!.x);
    const torDx = (t.tor!.x - s.tor!.x);
    const opp = (pelDx * torDx) < 0;
    const bigEnough = (Math.abs(pelDx) + Math.abs(torDx)) > (0.16 * scale);
    if (opp && bigEnough) faults.push("reverse_pivot");
  }

  // ARMS START DOWN proxy: hands drop early while pelvis hasn't started moving
  if (t) {
    const idxTop = track.findIndex(r => r.f === t.f);
    if (idxTop >= 0 && idxTop + 3 < track.length) {
      const f1 = track[idxTop];
      const f2 = track[idxTop + 3];

      const lw1 = lm(f1.f, L_WRIST), rw1 = lm(f1.f, R_WRIST);
      const lw2 = lm(f2.f, L_WRIST), rw2 = lm(f2.f, R_WRIST);

      const handY1 = lw1 && rw1 ? Math.min(lw1.y, rw1.y) : (lw1?.y ?? rw1?.y ?? null);
      const handY2 = lw2 && rw2 ? Math.min(lw2.y, rw2.y) : (lw2?.y ?? rw2?.y ?? null);

      if (handY1 !== null && handY2 !== null) {
        const handDrop = (handY2 - handY1);
        const pelMove = Math.abs((f2.pel!.x - f1.pel!.x));

        const handDropThresh = 0.22 * scale;
        const pelMoveThresh = 0.06 * scale;

        if (handDrop > handDropThresh && pelMove < pelMoveThresh) {
          faults.push("arms_start_down");
        }
      }
    }
  }

  if (!faults.length) faults.push("foundation");

  const okRate = track.filter(r => r.ok).length / track.length;
  const reliability = Math.round(60 + 40 * clamp01(okRate)); // 60–100

  const penalty = faults.includes("foundation") ? 0 : faults.length * 8;
  const swing = Math.max(35, Math.round(85 - penalty));

  const sep = median(track, r => Math.abs((r.tor!.x - r.pel!.x))) ?? 0;
  const power = Math.max(35, Math.round(70 + 60 * clamp01(sep / (0.35 * scale))));

  return {
    faults,
    metrics: {
      scale,
      framesUsed: track.length,
      pelRange,
      sway,
      setupFrame: setup?.frame ?? null,
      topFrame: top?.frame ?? null,
      impactFrame: impact?.frame ?? null,
      okRate,
      sep,
      scores: { swing, power, reliability },
    },
  };
}

export function postAssess(args: { pose?: PoseJson; base?: AnalyzeResponse } | AnalyzeResponse) {
  const base = (args as any)?.base ? (args as any).base : (args as any);
  const pose: PoseJson | undefined = (args as any)?.pose
    ? (args as any).pose
    : (base?.frames ? { fps: base?.fps, frames: base.frames } : undefined);

  const existing = (base?.faults ?? base?.faultKeys ?? []) as FaultKey[];
  let faults: FaultKey[] = Array.isArray(existing) ? [...existing] : [];

  let metrics: any = {};
  if (pose?.frames?.length) {
    const inferred = inferFaultsFromPose(pose);
    metrics = inferred.metrics;

    if (!faults.length || (faults.length === 1 && faults[0] === "foundation")) {
      faults = inferred.faults;
    } else {
      const set = new Set<FaultKey>(faults);
      for (const k of inferred.faults) set.add(k);
      faults = Array.from(set);
      if (faults.length > 1 && faults.includes("foundation")) {
        faults = faults.filter(f => f !== "foundation");
      }
    }
  } else {
    if (!faults.length) faults = ["foundation"];
  }

  const priority = pickOne(faults);

  const whyNow =
    priority === "foundation"
      ? "Lock in predictable contact first. Everything else gets easier once strike is stable."
      : `Fixing ${humanLabel(priority)} gives you the biggest “one move” gain right now—better starts, better strike, less chaos.`;

  const avoidList =
    priority === "face_open" || priority === "face_closed"
      ? "Avoid chasing swing path today. Face first, path second."
      : "Avoid chasing more speed today. Clean contact and sequence first.";

  const confidenceCue =
    "Expect a small confidence dip while you change the pattern. That’s normal—stay calm, take slower reps, and measure progress by contact + start line.";

  const scores = metrics?.scores ?? base?.scores ?? { swing: undefined, power: undefined, reliability: undefined };

  return {
    faults,
    faultKeys: faults,
    scores,
    narrative: {
      priorityKey: priority,
      priorityLabel: humanLabel(priority),
      whyNow,
      avoidList,
      confidenceCue,
      inferredFromPose: true,
      metrics,
    },

    priorityKey: priority,
    priorityLabel: humanLabel(priority),
    whyNow,
    avoidList,
    confidenceCue,
  };
}
