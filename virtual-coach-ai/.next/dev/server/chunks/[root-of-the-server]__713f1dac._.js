module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/src/app/api/video-analysis/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/client.mjs [app-route] (ecmascript) <export OpenAI as default>");
;
;
const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__["default"]({
    apiKey: process.env.OPENAI_API_KEY
});
const runtime = "nodejs";
async function POST(req) {
    try {
        const body = await req.json().catch(()=>({}));
        const { playerName = "Player", typicalBallFlight = "", typicalMiss = "", goals = "", notes = "", videoName = "" } = body || {};
        const context = `
Player: ${playerName}
Typical ball flight: ${typicalBallFlight}
Typical miss: ${typicalMiss}
Goals: ${goals}
Coach / self notes about swing: ${notes}
Video file name (for reference only): ${videoName || "not provided"}
`.trim();
        const systemPrompt = `
You are a golf coach giving VIDEO-BASED feedback on a player's full swing.

You do NOT actually see the video, but you DO see detailed written notes about the player's swing, ball flight, and goals.

Your job is to behave as if you just watched the swing on video and are summarizing what you saw.

Return ONLY valid JSON. No markdown, no commentary.

JSON shape:

{
  "summary": string, // conversational summary of what you "saw" on video
  "keyPositions": [
    {
      "label": string,  // "Setup", "P2 takeaway", "Top", "Impact", "Finish", etc.
      "focus": string,  // what this player should look for in that position on video
      "notes": string   // what they're likely doing now, based on the notes
    }
  ],
  "matchesToCheckpoints": string[], // 4–6 bullets like "Matches P3 checkpoint about lead arm depth"
  "swingKeysOnCourse": string[]     // 3–5 short, punchy keys for on-course swings
}
`.trim();
        const userPrompt = `
Using this player context, pretend you just watched their full swing video and generate JSON feedback:

${context}
`.trim();
        const response = await client.responses.create({
            model: "gpt-4.1-mini",
            input: [
                {
                    role: "system",
                    content: systemPrompt
                },
                {
                    role: "user",
                    content: userPrompt
                }
            ]
        });
        const first = response.output[0];
        let rawText = "";
        if (first.type === "message") {
            const contentItem = first.content.find((c)=>c.type === "output_text");
            if (contentItem?.text) {
                rawText = contentItem.text;
            }
        }
        if (!rawText) {
            throw new Error("No text returned from model");
        }
        rawText = rawText.trim();
        if (rawText.startsWith("```")) {
            rawText = rawText.replace(/```json/i, "").replace(/```$/, "").trim();
        }
        let analysis;
        try {
            analysis = JSON.parse(rawText);
        } catch (err) {
            console.error("Failed to parse JSON from model:", rawText);
            throw new Error("Model did not return valid JSON for video analysis");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            analysis
        });
    } catch (err) {
        console.error("video-analysis error:", err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: err?.message || "Unknown error"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__713f1dac._.js.map