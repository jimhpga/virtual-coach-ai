import { NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import os from "os";
import crypto from "crypto";
import { spawn } from "child_process";

export const runtime = "nodejs"; // ensure Node runtime (fs, spawn)
export const dynamic = "force-dynamic";

function ensureDir(p: string) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function run(cmd: string, args: string[]): Promise<void> {
  return new Promise((resolve, reject) => {
    const p = spawn(cmd, args, { windowsHide: true });
    let stderr = "";
    p.stderr.on("data", (d) => (stderr += d.toString()));
    p.on("close", (code) => {
      if (code === 0) resolve();
      else reject(new Error(`${cmd} failed (${code}): ${stderr}`));
    });
  });
}

export async function POST(req: Request) {
  try {
    const form = await req.formData();
    const file = form.get("file") as File | null;

    if (!file) {
      return NextResponse.json({ ok: false, error: "Missing file" }, { status: 400 });
    }

    // basic type guard (iPhone often sends video/quicktime)
    const mime = (file.type || "").toLowerCase();
    const allowed =
      mime.startsWith("video/") ||
      ["application/octet-stream"].includes(mime);

    if (!allowed) {
      return NextResponse.json({ ok: false, error: `Unsupported type: ${file.type}` }, { status: 400 });
    }

    const uploadId =
      (crypto.randomUUID && crypto.randomUUID()) ||
      crypto.randomBytes(16).toString("hex");

    // Always save final output here so Next can serve it
    const uploadsDir = path.join(process.cwd(), "public", "uploads");
    ensureDir(uploadsDir);

    const finalPath = path.join(uploadsDir, `${uploadId}.mp4`);
    const finalUrl = `/uploads/${uploadId}.mp4`;

    // write incoming file to temp
    const tmpIn = path.join(os.tmpdir(), `${uploadId}_in`);
    const ab = await file.arrayBuffer();
    fs.writeFileSync(tmpIn, Buffer.from(ab));

    // Decide whether to transcode:
    // - MOV -> transcode
    // - MP4 -> still might be huge; we can "normalize" anyway
    // We'll just always normalize to MP4/H.264/AAC for iPhone-proof playback.
    const tmpOut = path.join(os.tmpdir(), `${uploadId}_out.mp4`);

    // ffmpeg command: good quality, reasonable size, fast enough
    // You can tune CRF (18-28). 23 is a good default.
    await run("ffmpeg", [
      "-y",
      "-i", tmpIn,
      "-vf", "scale='min(1280,iw)':-2",
      "-c:v", "libx264",
      "-preset", "veryfast",
      "-crf", "23",
      "-c:a", "aac",
      "-b:a", "128k",
      "-movflags", "+faststart",
      tmpOut
    ]);

    // move into public/uploads (atomic-ish)
    fs.renameSync(tmpOut, finalPath);

    // cleanup temp input
    try { fs.unlinkSync(tmpIn); } catch {}

    const stat = fs.statSync(finalPath);
    const sizeMB = Math.round((stat.size / (1024 * 1024)) * 10) / 10;

    return NextResponse.json({
      ok: true,
      uploadId,
      video: {
        url: finalUrl,
        filename: `${uploadId}.mp4`,
        sizeMB,
      },
    });
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, error: e?.message || "Unknown error" },
      { status: 500 }
    );
  }
}

// Optional: GET to sanity check in browser
export async function GET() {
  return NextResponse.json({ ok: true, hint: "POST a file with form-data key 'file'." }, { status: 200 });
}
